# [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

## 1.题目描述

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。



**示例 1：**

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。



**示例 2：**

输入：height = [1,1]
输出：1



**示例 3：**

输入：height = [4,3,2,1,4]
输出：16



**示例 4：**

输入：height = [1,2,1]
输出：2



## 2.解题过程

我们假设第i个垂直线的高度为height[i]，第j个垂直线的高度为height[j]，i、j两条垂直线间的容量为s，可以得出：

s = min(height[i], height[j]) * (j - i)

**(1) 暴力解法**（时间复杂度O(n^2)）

双重循环，逐一区间遍历，直到遍历完成后，返回最大值；在当前中等难度的前提下，该解法无法通过。

```java
class Solution {
    public int maxArea(int[] height) {
        int len = height.length;
        int max = 0;
        for (int i = 0; i < len - 1; i++) {
            for (int j = i+1; j < len; j++) {
                int capacity = Math.min(height[j], height[i]) * (j-i);
                max = Math.max(max, capacity);
            }
        }
        return max;
    }
}
```

**（2）双指针解法**（时间复杂度O(n)）

从当前的题目描述来看，是一个木桶效应问题。我们可以了解到，在木桶效应问题中，保持长板不动，优化短板，能够得到最大的容积；这里我们使用双指针，一个在置于首端，一个置于尾端，不断优化短板，即移动对应值较小的指针，比较当前容积，最终当两个指针相遇时得到的最大容积则为结果。

```java
class Solution {
    public int maxArea(int[] height) {
        int max = 0;
        int i = 0;
        int j = height.length - 1;
        while (i != j) {
            int capacity = Math.min(height[j], height[i]) * (j - i);
            max = Math.max(max, capacity);
            if (height[i] < height[j]) {
                i++;
            } else {
                j--;
            }
        }
        return max;
    }
}
```

