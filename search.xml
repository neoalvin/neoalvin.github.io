<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo+Next+Github Pages搭建博客全流程]]></title>
    <url>%2F2019%2F05%2F10%2FHexo-Next-Github-Pages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[环境准备正式搭建博客前，我们需要检查环境上是否已安装下列程序： Git Nodejs Hexo 博客搭建//TODO]]></content>
      <categories>
        <category>总结分享</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Nodejs</tag>
        <tag>Git</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins插件开发（2）：开发新插件]]></title>
    <url>%2F2016%2F04%2F25%2FJenkins%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%882%EF%BC%89%EF%BC%9A%E5%BC%80%E5%8F%91%E6%96%B0%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/51245251 1.修改settings.xml文件，添加以下内容 12 &lt;settings&gt;&lt;pluginGroups&gt;&lt;pluginGroup&gt;org.jenkins-ci.tools&lt;/pluginGroup&gt;&lt;/pluginGroups&gt;&lt;profiles&gt;&lt;!-- Give access to Jenkins plugins --&gt;&lt;profile&gt;&lt;id&gt;jenkins&lt;/id&gt;&lt;activation&gt;&lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;!-- change this to false, if you don&#39;t like to have it on per default --&gt;&lt;/activation&gt;&lt;repositories&gt;&lt;repository&gt;&lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;&lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;&lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt;&lt;pluginRepository&gt;&lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;&lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;&lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;&lt;/profile&gt;&lt;/profiles&gt;&lt;mirrors&gt;&lt;mirror&gt;&lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;&lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;&lt;mirrorOf&gt;m.g.o-public&lt;/mirrorOf&gt;&lt;/mirror&gt;&lt;/mirrors&gt;&lt;/settings&gt; 2.创建新插件 12 #进入Jekins根目录，执行以下命令（会提示输入插件名）mvn -cpu hpi:create #进入新建插件的根目录，执行下面命令mvn package 问题： 12 Unable to find /home/alvin/Documents/Program/jenkins/war/target/jenkins/WEB-INF/ 解决方法：按照提示路径手动创建新文件夹 3.进入插件根目录，执行下面命令设置插件的eclipse开发环境 12 mvn -DdownloadSources=true -DdownloadJavadocs=true -DoutputDirectory=target/eclipse-classes eclipse:eclipse 4.导入eclipse,修改代码之后执行下面命令 12 mvn package 执行该命令后在插件主目录下的target文件夹中会生成一个.hpi文件，将其导入到jenkins中。下图为导入后的效果：]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins插件开发笔记（1）：导入Jenkins源码]]></title>
    <url>%2F2016%2F04%2F25%2FJenkins%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E5%AF%BC%E5%85%A5Jenkins%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/51245243 环境配置 1.下载并配置JDK http://www.linuxidc.com/Linux/2015-01/112030.htm 2.下载并配置Maven http://www.cnblogs.com/0616–ataozhijia/p/3673964.html 导入eclipse项目 1.通过git获取Jekins源码git clone https://github.com/jenkinsci/jenkins.git 2.修改${USER_HOME}/.m2/settings.xml文件，添加以下内容 12 &lt;settings&gt;&lt;pluginGroups&gt;&lt;pluginGroup&gt;org.jenkins-ci.tools&lt;/pluginGroup&gt;&lt;/pluginGroups&gt;&lt;profiles&gt;&lt;!-- Give access to Jenkins plugins --&gt;&lt;profile&gt;&lt;id&gt;jenkins&lt;/id&gt;&lt;activation&gt;&lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;!-- change this to false, if you don&#39;t like to have it on per default --&gt;&lt;/activation&gt;&lt;repositories&gt;&lt;repository&gt;&lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;&lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;&lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt;&lt;pluginRepository&gt;&lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;&lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;&lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;&lt;/profile&gt;&lt;/profiles&gt;&lt;mirrors&gt;&lt;mirror&gt;&lt;id&gt;repo.jenkins-ci.org&lt;/id&gt;&lt;url&gt;http://repo.jenkins-ci.org/public/&lt;/url&gt;&lt;mirrorOf&gt;m.g.o-public&lt;/mirrorOf&gt;&lt;/mirror&gt;&lt;/mirrors&gt;&lt;/settings&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&lt;version&gt;2.19.1&lt;/version&gt;&lt;extensions&gt;true&lt;/extensions&gt;&lt;/dependency&gt; 3.进入主目录，执行以下命令生成eclipse项目 mvn -DdownloadSources=true eclipse:eclipse 问题1 （1）Build期间遇到依赖包的问题卡在了jenkins-core,加上了第2 步中下方的得到解决； （2）Build期间卡在了test for jenkins-core,同样因为依赖包的问题，不过这里是因为网络原因，挂上VPN重新来过就好了。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu14.04下利用pypi-server搭建本地的pip库]]></title>
    <url>%2F2016%2F01%2F19%2Fubuntu14.04%E4%B8%8B%E5%88%A9%E7%94%A8pypi-server%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E7%9A%84pip%E5%BA%93%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/50544503 12 应实验室需要，自己动手实现了一个pip本地仓库。其实搭建起来很简单，重点在于对本地不存在包的处理。这里我设置的机制是当本地不存在所请求的包时继续维持连接，同时从阿里的pip镜像源中将该包下载到本地以供用户下载。于是，问题主要在于获取所缺失包的信息。 我的解决方法是：当pypi-server在本地找不到所请求包时跳转到主机的另一端口，在此端口上运行一个监听程序，从HTTP请求中获取所要下载的包，然后从阿里的pip镜像库中将该包下载到本地。 1.下载pypi-server 跳转下载 2.pypi-server的使用 pypi-server [option] packages_path 中间可以跟相关的参数，最后跟上本地存储路径 这里只说明一些我所用到的参数： -p 指明pypi-server所在的端口 –disable-fallback 禁止在找不到包的时候跳转到pypi官网链接 –fallback-url [url]指明找不到包需要跳转的链接 如：pypi-server -p 8080 –fallback-url http://localhost:9000 ~/pypi-packages pypi-server运行在主机的8080端口，若找不到所请求的包，则跳转到主机的9000端口，本地存储路径为~/pypi-packages 3.监听程序 前一个版本的在使用过程中遇到问题，即pip用户在找不到包时会不断的发送请求，于是本地仓库中便会有大量重复的包。 解决方法：下载包之前先判断当前目录下是否已经存在，存在则直接跳过….. 12&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;/span&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;span style=&quot;font-size:18px;&quot;&gt;#coding:utf-8import threadingimport socketimport reimport osimport urllibimport urllib.request as urllib2encoding = &apos;utf-8&apos;BUFSIZE = 1024# a read thread, read data from remoteclass Reader(threading.Thread):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;def __init__(self, client):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;threading.Thread.__init__(self)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.client = client&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.index_url=&quot;http://mirrors.aliyun.com/pypi/simple/&quot;&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.dir_url=&quot;http://mirrors.aliyun.com/pypi/packages/source/&quot;&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.pkgname=&quot;&quot;&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.pkgdir=[]&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.pkglist=[]&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.storepath=&quot;~/pypi/&quot; &lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;def run(self):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;while True:&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;f=open(&quot;listen.log&quot;,&quot;a+&quot;)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;data = self.client.recv(BUFSIZE)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;if(data):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;string = bytes.decode(data, encoding)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;f.writelines(string)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.pkgname=re.findall(&quot;GET /(.*?)/&quot;,string)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.pkgname=&quot;&quot;.join(self.pkgname)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;f.writelines(&quot;*******the pkgname: &quot;+self.pkgname+&quot;*******&quot;)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.getpkgdir()&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;pkgdir=self.pkgdir&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;for pkg in pkgdir:&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;if os.path.exists(self.storepath+pkg[1]):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;print(&quot;pkg exists!&quot;)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;break&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;else:&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.download(self.dir_url+pkg[0])&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;else:&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;break&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;peername=self.client.getpeername()&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;f.writelines(&quot;close:&quot;+str(peername))&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;f.writelines(&quot;\n=============================================\n&quot;)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;f.close()&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;def getpkgdir(self):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;pkg_url=self.index_url+self.pkgname&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;request=urllib2.Request(pkg_url)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;response=urllib2.urlopen(request)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;data=response.read().decode(&quot;utf-8&quot;)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.pkgdir=re.findall(&apos;&lt;a href=&quot;.*?source/(.*?)&quot; rel=&quot;internal&quot;&gt;(.*?)&lt;/a&gt;&apos;,data)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;def download(self,url):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;os.system(&quot;wget -P %s %s&quot;%(self.storepath,url)) &lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;def readline(self):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;rec = self.inputs.readline()&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;if rec:&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;string = bytes.decode(rec, encoding)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;if len(string)&gt;2:&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;string = string[0:-2]&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;else:&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;string = &apos; &apos;&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;else:&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;string = False&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;return string# a listen thread, listen remote connect# when a remote machine request to connect, it will create a read thread to handleclass Listener(threading.Thread):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;def __init__(self, port):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;threading.Thread.__init__(self)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.port = port&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.sock.bind((&quot;0.0.0.0&quot;, port))&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;self.sock.listen(0)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;def run(self):&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;print(&quot;listener started&quot;)&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;while True:&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;client, cltadd = self.sock.accept()&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;Reader(client).start()&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;cltadd = cltadd&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;print(&quot;accept a connect&quot;)lst = Listener(8080) # create a listen threadlst.start() # then start&lt;/span&gt; 12&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;/span&gt; 4.pip下载 pip install [packagename] -i http://localhost:8080/simple 利用上述命令则可以从本地pip库中下载所需的包 或者利用下述办法，可直接利用pip install [packagename]命令从本地源下载： 1&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;/span&gt;&lt;pre name=&quot;code&quot; class=&quot;plain&quot;&gt;&lt;span style=&quot;font-size:18px;&quot;&gt;//在主文件夹下新建.pip文件夹&lt;/span&gt; 1&lt;span style=&quot;font-size:18px;&quot;&gt;mkdir ~/.pip&lt;/span&gt; 12 12&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;/span&gt; 1&lt;span style=&quot;font-size:18px;&quot;&gt;cd ~/.pip&lt;/span&gt; 1&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;/span&gt;&lt;pre name=&quot;code&quot; class=&quot;plain&quot;&gt;&lt;span style=&quot;font-size:18px;&quot;&gt;//在文件夹.pip中新建pip.conf文件&lt;/span&gt; vim pip.conf 12 12&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;/span&gt; 12&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;/span&gt; 1234&lt;span style=&quot;font-size:18px;&quot;&gt;//在pip.conf文件中添加以下内容[global]index-url = http://localhost:8080/simple&lt;/span&gt; 12&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;/span&gt;]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下python+flask+mysql完整开发环境配置]]></title>
    <url>%2F2015%2F12%2F22%2Fubuntu%E4%B8%8Bpython%2Bflask%2Bmysql%E5%AE%8C%E6%95%B4%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/50377867 捣腾flask快两个月了，即使中间三个周准备考试没怎么再碰过。一直想写一点自己的经验什么的，就先从环境配置开始吧。 最开始安装flask环境的时候挺纠结的，因为个人还是比较追求完美的类型，做什么都想能一次做到最好。显然网络上的环境配置教程对我来说都是残缺不全的，于是就一路百度加Bing过来，选择了一套最完整的方案。 运行环境： ubantu15.04 python2.7 1.python 12345678910111213141516171819202122#安装必要的依赖包sudo apt-get install python-dev build-essential libssl-dev libevent-dev libjpeg-dev libxml2-dev libxslt-dev#安装pipsudo apt-get install python-pip#安装virtualenv虚拟环境sudo pip install virtualenv1.~$ mkdir .venv #创建目录用于存放虚拟环境2.sudo pip install virtualenvwrapper3.sudo gedit ~/.bashrc添加行： if [ -f /usr/local/bin/virtualenvwrapper.sh ]; then export WORKON_HOME=$HOME/.venv #默认将虚拟环境存在.venv文件夹 source /usr/local/bin/virtualenvwrapper.shfi 4.~$ source ~/.bashrc5.mkvirtualenv flask #创建名为flask的虚拟环境6.sudo gedit ~/.bashrc添加以下内容：if [ -f ~/.venv/flask/bin/activate ]; then . ~/.venv/flask/bin/activatefi虚拟环境配置完毕，打开终端会发现用户名前面多了一个（flask）,则环境配置成功 12 12 2.flask 想省事不想按下面一个个安装的小伙伴可以将以下复制粘贴，文件名命为requirements.txt 12345678910111213141516171819202122Flask==0.10.1Flask-Login==0.2.11Flask-Mail==0.9.1Flask-Moment==0.4.0Flask-PageDown==0.1.5Flask-SQLAlchemy==2.0Flask-Script==2.0.5Flask-WTF==0.10.2Flask-Cache==0.13.1Flask-Restless==0.15.0Flask-Uploads==0.1.3Jinja2==2.7.3Mako==1.0.0Markdown==2.5.1MarkupSafe==0.23SQLAlchemy==0.9.8WTForms==2.0.1Werkzeug==0.9.6html5lib==1.0b3itsdangerous==0.24six==1.8.0awesome-slugify==1.6 然后到该文件目录打开终端运行以下命令(不过不能保证是最新的哈)： 1pip install -r requirements.txt 123456789101112131415161718192021pip install flask-loginpip install flask-openidpip install flask-mailpip install flask-momentpip install flask-pagedownpip install flask-scriptpip install flask-cachepip install flask-restlesspip install flask-uploadspip install flask-sqlalchemypip install sqlalchemy-migratepip install flask-whooshalchemypip install flask-wtfpip install flask-babelpip install jinja2pip install mokapip install markdownpip install WTFormspip install Werkzeugpip install html5libpip install flup 以上flask包可以按照自己的需求来安装。 3.mysql 11.sudo apt-get install mysql-server mysql-client #跳出一个界面让你输入密码，也就是你只后进入mysql的密码 1232.命令行输入：mysql -u root -p你的密码 #-p跟密码之间没有空格,显示mysql&gt;就说明mysql已经装好啦3.pip install mysql-python #安装python的mysql包 1234#第3步可能会出现not found mysql_config的错误，运行以下命令再重新回到2步骤即可sudo apt-get install libmysqlclient-dev4.打开python运行：import MySQLdb #若无错误提示，则安装成功 环境配置到此结束，希望能和大家一起共同学习，共同进步。有什么不周之处还请尽量指正，谢谢 借鉴链接： 配置舒服的python开发环境 虚拟环境virtualenv的安装配置 mysql-python安装时EnvironmentError: mysql_config not found]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker私有仓库搭建完整记录（直接pull方式）]]></title>
    <url>%2F2015%2F12%2F10%2Fdocker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%95%B4%E8%AE%B0%E5%BD%95%EF%BC%88%E7%9B%B4%E6%8E%A5pull%E6%96%B9%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/50244369 1.安装docker-registry #直接从官网pull镜像registry,简单粗暴。国内可能速度较慢，考虑挂VPN docker pull registry 按照上一篇中的方式修改–insecure-registry设置及config.yml文件 2.运行docker-registry #后台启动registry,其中/home/alvin/registry为我本地仓库的存储路径 docker run -d -v /home/alvin/registry:/tmp/registry -p 5000:5000 -e DOCKER_REGISTRY_CONFIG=/tmp/registry/config.yml registry 问题记录：每次重新运行时镜像丢失 解决方法：修改仓库路径到本地 docker run -d -e SETTINGS_FLAVOR=dev -e STORAGE_PATH=/tmp/registry -v /home/alvin/registry:/tmp/registry -p 5000:5000 registry 至此已经可以正常的push/pull操作了 3.nginx代理认证 #安装nginx sudo apt-get install -y nginx apache2-utils #创建用户名及密码 sudo htpasswd -c /etc/nginx/docker-registry.htpasswd [USERNAME] #配置nginx认证文件 sudo vim /etc/nginx/sites-available/docker-registry #文件中写入下面内容： 12345678910111213141516171819202122232425262728293031323334353637383940# For versions of Nginx &gt; 1.3.9 that include chunked transfer encoding support# Replace with appropriate values where necessary upstream docker-registry &#123; server localhost:5000;&#125; server &#123; listen 8080; server_name 192.168.32.139; # ssl on; # ssl_certificate /etc/ssl/certs/docker-registry; # ssl_certificate_key /etc/ssl/private/docker-registry; proxy_set_header Host $http_host; # required for Docker client sake proxy_set_header X-Real-IP $remote_addr; # pass on real client IP client_max_body_size 0; # disable any limits to avoid HTTP 413 for large image uploads # required to avoid HTTP 411: see Issue #1486 (https://github.com/dotcloud/docker/issues/1486) chunked_transfer_encoding on; location / &#123; # let Nginx know about our auth file auth_basic &quot;Restricted&quot;; auth_basic_user_file docker-registry.htpasswd; proxy_pass http://docker-registry; &#125; location /_ping &#123; auth_basic off; proxy_pass http://docker-registry; &#125; location /v1/_ping &#123; auth_basic off; proxy_pass http://docker-registry; &#125; &#125; 其中server_name改为主机的ip或域名 #链接配置文件到nginx sudo ln -s /etc/nginx/sites-available/docker-registry /etc/nginx/sites-enabled/docker-registry #重启nginx服务 sudo service nginx restart 可以通过ip:8080来访问私有仓库了，并且有用户认证功能]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker私有仓库搭建完整记录(git方式)]]></title>
    <url>%2F2015%2F12%2F09%2Fdocker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%95%B4%E8%AE%B0%E5%BD%95(git%E6%96%B9%E5%BC%8F)%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/50242787 1.本地安装docker-registry #安装相关环境依赖sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev liblzma-dev libffi-dev #git下载docker-registrygit clone https://github.com/docker/docker-registry.gitcd docker-registry #安装docker-registrysudo python setup.py install问题记录：到这一步进行的过程中需要安装requirments.txt中的相关模块，在此安装到其中一个时出现错误：/**/Searching for M2Crypto==0.22.3…..unable to execute ‘swig’: No such file or directoryerror: Setup script exited with error: command ‘swig’ failed with exit status 1/**/解决方法：sudo apt-get install swigsudo apt-get install python-m2crypto相关链接：http://stackoverflow.com/questions/7772965/m2crypto-doesnt-install-in-venv-or-swig-doesnt-define-x86-64-which-breaks 在刚才的目录中重新执行：sudo python setup.py install 可以看到安装顺利，没有出现错误 2.运行docker-registry #修改配置文件config.ymlcp config/config_sample.yml config/config.yml #打开config.yml文件，将dev:下storage_path的值改为本地仓库存储的路径sudo vim config/config.yml #运行docker-registrysudo gunicorn –access-logfile - –error-logfile - -k gevent -b 0.0.0.0:5000 -w 4 –max-requests 100 docker_registry.wsgi:application问题记录：此处直接运行时会报错/***/FileNotFoundError: Heads-up! File is missing: /usr/local/lib/python2.7/dist-packages/docker_registry-1.0.0_dev-py2.7.egg/docker_registry/lib/../../config/config.yml……gunicorn.errors.HaltServer: /***/原因显然是上面提示的文件缺失，我们修改了当前目录下的config.yml文件，但是运行时调用的是系统目录下的文件，而config.yml此时是不存在的 解决方法：cd /usr/local/lib/python2.7/dist-packages/docker_registry-1.0.0_dev-py2.7.egg/configcp config_sample.yml config.yml注：同上，需修改config.yml中dev:下storage_path的值为本地仓库存储的路径，没有则添加 #再次运行sudo gunicorn –access-logfile - –error-logfile - -k gevent -b 0.0.0.0:5000 -w 4 –max-requests 100 docker_registry.wsgi:application 运行成功，访问0.0.0.0:5000时可以看到docker-registry 的版本信息说明 3.push/pull镜像到私有仓库 #先从官网pull一个简单的镜像用作测试docker pull busybox #更改镜像tag,192.168.32.139为本地ipdocker tag busybox 192.168.32.139:5000/busybox #push镜像到私有仓库docker push 192.168.32.139:5000/busybox 问题记录:到这一步会提示错误/**/unable to ping registry endpoint https://192.168.32.139:5000/v0/v2 ping attempt failed with error: Get https://192.168.32.139:5000/v2/: EOF v1 ping attempt failed with error: Get https://192.168.32.139:5000/v1/_ping: EOF/**/原因在于docker daemon 的启动参数设置问题，应该添加：–insecure-registry=192.168.32.139:5000用一般添加的方式操作之后发现错误并没有得到解决，知道找到网上的一篇博文 解决方法： #打开docker启动文件sudo vim /etc/default/docker #在文件末尾添加OPTIONS字段OPTIONS=–insecure-registry 192.168.32.139:5000 #打开系统中docker.service文件sudo vim /lib/systemd/system/docker.service #在文件中的[Service]下添加并修改下面两行：EnvironmentFile=-/etc/default/dockerExecStart=/usr/bin/docker -d -H fd:// $OPTIONS #重新加载参数sudo systemctl daemon-reload #重启服务sudo systemctl restart docker 问题至此得到解决，可以正常的在私有仓库中push/pull镜像]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker笔记（1）--常用命令]]></title>
    <url>%2F2015%2F11%2F21%2FDocker%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/49962423 1.安装docker 安装配置过程见上一篇博文 点击打开链接 2.查看镜像 sudo docker images #查看所有镜像历史过程 sudo docker images –tree 3.下载镜像pull sudo docker pull [镜像名] 实例：sudo docker pull ubuntu:15.04 4.运行镜像 sudo docker run -it [镜像名] bash#打开镜像下的命令行 sudo docker run -it [镜像名] python xxx.py#运行镜像根目录下的xxx.py文件 注：若不带参数-it,则py代码中的print会推迟运行 4.导入镜像load sudo docker load -i [镜像.tar/.img文件] 实例：sudo docker load -i ubuntu.img 5.导出镜像 sudo docker save -o [压缩包名] [镜像名] 实例：sudo docker save -o ubuntu.img ubuntu:15.04 6.生成镜像 sudo docker build -t [镜像名] . 最后一个句点不要忘了，而且要保证当前目录下有Dockerfile]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下sublime_text_3输入中文]]></title>
    <url>%2F2015%2F11%2F21%2Fubuntu%E4%B8%8Bsublime_text_3%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/49962421 每次重新配置时候总要做这一步，不过百度首条检索结果是有问题的，还是在这里记录一下解决方法吧 1234567891011121314151617#include &lt;gtk/gtkimcontext.h&gt;void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&gt;set_client_window) klass-&gt;set_client_window (context, window); g_object_set_data(G_OBJECT(context),&quot;window&quot;,window); if(!GDK_IS_WINDOW (window)) return; int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;&amp; height !=0) gtk_im_context_focus_in(context);&#125; 1.将代码保存到文件sublime_imfix.c 2.然后到该目录下执行 gcc -shared -o libsublime-imfix.so sublime_imfix.c pkg-config --libs --cflags gtk+-2.0 -fPIC 这里可能会报错：No package ‘gtk+-2.0’ found 解决方法：sudo apt-get install libgtk2.0-dev 然后再重新执行第二步中的命令 接下来的步骤就跟原链接中一样了 点击打开链接]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu server 14.04设置图形化界面及相关配置]]></title>
    <url>%2F2015%2F11%2F21%2FUbuntu%20server%2014.04%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/49962419 最近接触到一个利用相关工具建立网络拓扑的题目，查阅相关资料发现Ubuntu server的环境会更适合。于是又开始折腾之路…….. 当然，由于之前的各种装系统经验，安装这一步骤就不算什么了。因为ubuntu server默认都是不带图形化界面的，用起来略不方便吧，所以还是贴一下图形化界面以及后续相关配置的一些步骤： 1.安装图形化界面 sudo apt-get install xinit sudo apt-get install gdm sudo apt-get install ubuntu-desktop 当然，如果更喜欢kubuntu的界面，最后一步也可以改成sudo apt-get install kubuntu-desktop 这个过程耗费的时间当然就是依网速而定喏，强烈建议国内的盆友安装的时候最好选择中文版或者香港英文版，因为墙的原因获取包的速度真是慢到令人发指，所以第一遍果断放弃了改成香港英文版再进行了上面的操作。 还有一些后续的配置稍后再一一贴出来吧 2.添加右键打开终端功能 sudo apt-get install nautilus-open-terminal 注销或重启一下就可以使用了]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python+MySQL获取PhishTank的钓鱼网站列表作业笔记]]></title>
    <url>%2F2015%2F11%2F21%2FPython%2BMySQL%E8%8E%B7%E5%8F%96PhishTank%E7%9A%84%E9%92%93%E9%B1%BC%E7%BD%91%E7%AB%99%E5%88%97%E8%A1%A8%E4%BD%9C%E4%B8%9A%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/49962417 仔细阅读PhishTank官方网站的开发者文档，了解API调用方法 1.注册账户，创建application并获取app_key 2.根据http://data.phishtank.com/data//online-valid.xml下载数据库导出文件.xml 于是便将问题转化为python解析xml大文件 Then 分别用xml.dom和xml.sax尝试去解析文档，均遇到相同问题： xml.parsers.expat.ExpatError: not well-formed (invalid token): line 16519, column 83 xml.sax._exceptions.SAXParseException: online-valid.xml:16519:83: not well-formed (invalid token) 显然根据提示我们知道是xml文件中存在非法字符 接下来要解决的问题就是如何处理xml中的非法字符了（开启疯狂BG模式～～～） 几番B搜无果，最后在G搜到类似的内容： 123456789101112131415161718192021222324252627#!/usr/bin/python# -*- coding:utf-8 -*- import stringimport xml.dom.minidom def parse_xml(file_path): &quot;&quot;&quot; Handle xml file with invalid character [input] : path of the xml file [output] : xml.dom.minidom.Document instance &quot;&quot;&quot; try: xmldoc = xml.dom.minidom.parse(file_path) except: f = file(file_path) s = f.read() f.close() ss = s.translate(None, string.printable) s = s.translate(None, ss) xmldoc = xml.dom.minidom.parseString(s) return xmldoc if __name__ == &apos;__main__&apos;: pass 以纯文本当时读取文件，然后用字符串来处理，就能得到非法字符完全剔除的的结果了 于是作业也就可以愉快的进行下去啦 版权声明：本文为博主原创文章，未经博主允许不得转载。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu15.04下安装配置docker]]></title>
    <url>%2F2015%2F11%2F21%2Fubuntu15.04%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEdocker%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/49962413 Docker是一种轻量型的的类虚拟机的平台，在开发项目上还是很有优势的，这仅是我的一种直观理解。最近老师让装上docker来编写代码便于提交，故此又开始了折腾，也还是出现了不少问题，在这里照例贴一下： 1.安装过程 方法1：当然就是直接安装ubuntu15.04自带的docker包啦，不过版本号是1.6的，并非最新版本 sudo apt-get update sudo apt-get install docker.io 方法2：这种方式安装的自然就是最新版本的啦 sudo apt-get update wget -qO- https://get.docker.com/ | sh 2.相关配置： sudo usermod -a -G docker $USER#将当前用户加入到docker用户组中 sudo gedit /etc/default/docker#修改配置文件 DOCKER=”/usr/bin/docker” #在配置文件中添加或修改此项 sudo service docker restart #重启 3.测试 docker -v#在命令行中输入显示版本号则表示安装成功 sudo service docker start#启动docker服务 sudo service docker status#查看docker运行状态，若显示成功就ok啦 版权声明：本文为博主原创文章，未经博主允许不得转载。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下使用cx_freeze将Python程序打包成exe可执行文件]]></title>
    <url>%2F2015%2F11%2F21%2Fwindows%E4%B8%8B%E4%BD%BF%E7%94%A8cx_freeze%E5%B0%86Python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90exe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/49962405 1.cxfreeze**安装** https://pypi.python.org/pypi/cx_Freeze 在以上地址可下载最新版本，选择适合自己python版本的安装包。安装过程中会自动识别你的python路径，确保是安装在Python目录下的Lib\site-packages\文件夹下。 2.相关配置 安装结束后，在python根目录下的Scripts文件夹下会多出cxfreeze相关文件，我安装完之后多出了三个cxfreeze开头的文件，都没有后缀名，明显是无法运行的。于是我手动添加上了.py，事实证明我还是蛮机智的。 不过现在还是无法正常运行，还需要将cxfreeze.py文件第一行修改成自己的python路径，另外两个文件也可以不用修改。为使用方便我将Scripts文件夹路径添加到环境变量path中，便于直接调用 3.程序打包 使用就很简单啦，到项目根目录下运行以下命令： cxfreeze xxx.py –target-dir dist –base-name=win32gui_path xxx.py即项目的主文件 –target-dir用来指定保存路径，dist即保存项目的路径 –base-name用来指定Win32GUI路径，win32gui_path即Win32GUI的路径，如D:\xxxx\cx_freeze/bases/Win32GUI.exe 指定–base-name可使运行exe程序时不跳出cmd窗口 版权声明：本文为博主原创文章，未经博主允许不得转载。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式学习小结]]></title>
    <url>%2F2015%2F11%2F21%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/49962401 重复和置位字符 ? //匹配零个或一个在它之前的表达式 //匹配在它之前的表达式一次或多次出现 //匹配在它之前的表达式零次或多次出现 ^ //表示处于字符串开头 $ //表示处于字符串结尾 . //除换行符之外的其他任意字符 字符类和特殊序列 \ //转义元字符 [a-d] //匹配a,b,c或d [^a-d] //匹配除a,b,c,d以外的任意字符 a|b|c //同[abc] \d //数位类,[0-9] \D //非数位类，[^0-9] \s //空白字符类，[\n\f\r\t\v] \S //非空白字符类，[^\n\f\r\t\v] \w //字母、数字类，[a-zA-Z0-9] \W //非字母数字类，[^a-zA-Z0-9] \ //反斜杠 r”a\nb” //原始字符串，\不作为转义字符，仅为字面意义的反斜杠 字符串处理函数 import re //引入正则表达式模块re re.search(expression,string) //在字符串的任意部分和表达式匹配时返回一个SRE_Match对象 re.match(expression,string) //在字符串开头与表达式匹配的前提下返回一个SRE_Match对象 re.sub(expression,substring,string) //将字符串string中与expression指定模式匹配的子字符串替换为substring re.split(expression,string) //以模式expression为定界符，对字符串string进行分解 版权声明：本文为博主原创文章，未经博主允许不得转载。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu环境下利用Python3+PyQt5+Eric6进行GUI编程]]></title>
    <url>%2F2015%2F11%2F21%2FUbuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%88%A9%E7%94%A8Python3%2BPyQt5%2BEric6%E8%BF%9B%E8%A1%8CGUI%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/49962397 首先当然是要配置环境啦，这里特别感谢@ideber的文章，安装过程已经非常详细了。 原文地址：http://blog.csdn.net/idber/article/details/40076821 下面贴出一些我在安装过程中遇到的问题： 1.安装PyQt5时失败，提示：This version of PyQt5 and the commercial version of Qt have incompatible licenses. 网上都说开源版本有自带的GPL协议，我也不知道为什么这里还会有这一项提示，于是就只好向度娘求救啦，自然是功夫不负有心人 解决方法：在解压后的PyQt文件夹中找到configure.py文件并打开，将2590行之后的下面这一段代码注释掉就OK啦 12345# Common checks.if introspecting and target_config.qt_licensee != &apos;Open Source&apos; and ltype == &apos;GPL&apos;: error( &quot;This version of PyQt5 and the commercial version of Qt have &quot; &quot;incompatible licenses.&quot;) 2.为保证PyQt5能够正常使用，安装前需配置依赖环境 1&lt;strong&gt;解决方法&lt;/strong&gt;：sudo apt-get install PyQt5-dev 3.同样，在安装Qscintilla2前也需配置相应环境 1解决方法：sudo apt-get install libqscintilla2* 为了省事，我就不管三七二十一把相关的包都装上了 还有一些问题没来得及记录，不过度娘是万能的你懂的~.~ 接下来就是愉快的编程啦~~ 版权声明：本文为博主原创文章，未经博主允许不得转载。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#学习笔记——控件篇]]></title>
    <url>%2F2015%2F11%2F21%2FC%23%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8E%A7%E4%BB%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/neoalvin/article/details/49962393 数据库系统课程设计已经过去好几天了，两周的课程设计强度除了强制到场其实强度并不大。起初的任务书原版本是以python语言为基础在flask框架下完成，不过因为涉及到频繁的表单操作，而这恰恰也是我还并不太熟练的部分，于是果断改用了C#。 虽然之前并未尝试过C#编程，但由于之前有一些语言基础，加之C#窗体编程的傻瓜式操作，方便的界面设计，so用了两天时间熟悉了一下C#窗体控件便开始了自己的课程设计。下面记录一下我所使用的一些基本的C#窗体控件： 1.TreeView控件 一般用作目录或菜单 1234567891011121314151617181920212223&lt;pre name=&quot;code&quot; class=&quot;csharp&quot; style=&quot;font-size: 13.3333339691162px;&quot;&gt;&lt;span style=&quot;font-family:Microsoft YaHei;font-size:12px;&quot;&gt;//初始化树形菜单控件 public void initTree() &#123; TreeNode node = new TreeNode(); //设置Treeview上方间距 myTree.Top = 94; //myTree为控件名 //添加根节点 string[] TreeStr = new string[5] &#123; &quot;用户操作&quot;, &quot;前台服务&quot;, &quot;后台管理&quot;, &quot;系统设置&quot; ,&quot;退出系统&quot;&#125;; for (int i = 0; i &lt;= 4; i++) &#123; myTree.Nodes.Add(new TreeNode(TreeStr[i])); myTree.Nodes[i].ForeColor = Color.Black; myTree.Nodes[i].ExpandAll(); &#125; //添加子节点 myTree.Nodes[0].Nodes.Add(&quot;用户登录&quot;); myTree.Nodes[0].Nodes.Add(&quot;用户注册&quot;); myTree.Nodes[1].Nodes.Add(&quot;宾客登记&quot;); myTree.Nodes[1].Nodes.Add(&quot;宾客退房&quot;); myTree.Nodes[1].Nodes.Add(&quot;宾客预约&quot;); myTree.Nodes[2].Nodes.Add(&quot;客户管理&quot;); myTree.Nodes[2].Nodes.Add(&quot;客房管理&quot;); &#125;&lt;/span&gt; 12 123456789101112&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt;//TreeView点击事件TreeNode node = new TreeNode();node = myTree.SelectedNode; //node为选中的节点if(node.Text==&quot;用户操作&quot;)&#123;//完成相应操作&#125;else if(node.Text==&quot;前台服务&quot;)&#123;//完成相应操作&#125;else if.......&lt;/span&gt; 12345678910111213141516171819202122&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt;//节点光标随界面跳转移动 public void focusNode(string nText) &#123; myTree.Focus(); for (int i = 0; i &lt; myTree.Nodes.Count; i++) &#123; for (int j = 0; j &lt; myTree.Nodes[i].Nodes.Count; j++) &#123; if (myTree.Nodes[i].Nodes[j].Text == nText) &#123; myTree.SelectedNode = myTree.Nodes[i].Nodes[j];//第二层节点选中 &#125; for (int k = 0; k &lt; myTree.Nodes[i].Nodes[j].Nodes.Count; k++) &#123; if (myTree.Nodes[i].Nodes[j].Nodes[k].Text == nText) &#123; myTree.SelectedNode = myTree.Nodes[i].Nodes[j].Nodes[k];//第三层节点选中 &#125; &#125; &#125; &#125; &#125;&lt;/span&gt; 2.Panel控件 一般用作其他控件的容器，这里我将其用来实现在同一主页根据菜单展示不同的功能界面 1234567891011&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt;//切换用户注册界面 public void panel_Reg() &#123; focusNode(&quot;用户注册&quot;);&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//TreeView节点光标移动 RegitForm reg = new RegitForm();&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//为用户注册界面窗口建立一个对象 reg.Home = this;&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//用户注册类中的Home为主窗口的一个对象，此行代码加入后方能生效 reg.TopLevel = false; this.mainPanel.Controls.Clear(); /清除panel控件中原有内容，mainPanel为Panel控件名 this.mainPanel.Controls.Add(reg); //添加用户注册窗口到Panel控件 reg.Show(); //展示用户注册窗口 &#125;&lt;/span&gt; 3.ListView控件 一般用作数据的展示 123&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt;//初始化ListView，roomList为控件名 public void initListView() &#123;&lt;/span&gt; 123456789101112131415161718&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt;//添加表头 roomList.Columns.Add(&quot;客房号&quot;, 110, HorizontalAlignment.Center);&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt; roomList.Columns.Add(&quot;类型&quot;, 130, HorizontalAlignment.Center); roomList.Columns.Add(&quot;价格&quot;, 100, HorizontalAlignment.Center); roomList.Columns.Add(&quot;入住状态&quot;, 100, HorizontalAlignment.Center); roomList.Columns.Add(&quot;预约状态&quot;, 100, HorizontalAlignment.Center); roomList.Columns.Add(&quot;预约时间&quot;, 110, HorizontalAlignment.Center);&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;//将数据集DataSet中的数据内容添加到ListView中 for (int i = 0; i &lt; dataSet.Tables[0].Rows.Count; i++) &#123; ListViewItem item = roomList.Items.Add(dataSet.Tables[0].Rows[i][0].ToString()); for (int j = 1; j &lt; dataSet.Tables[0].Columns.Count; j++) &#123; item.SubItems.Add(dataSet.Tables[0].Rows[i][j].ToString()); &#125; &#125; dataSet.Dispose();&lt;span style=&quot;white-space:pre&quot;&gt; &lt;/span&gt;&#125;&lt;/span&gt; 4.ComboBox（下拉列表）控件 12345&lt;span style=&quot;font-family:Microsoft YaHei;font-size:12px;&quot;&gt;//初始化控件，combType为控件名 combType.Items.Add(//内容);//使用控件combType.Text为选中项&lt;/span&gt; 5.DateTimePicker（时间选择）控件 1&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt;datePicker.Value.ToString(&quot;yyyy-MM-dd&quot;);//日期格式&lt;/span&gt; 6.TabControl控件 比mfc好操作的多，并不需要自己建立子窗口，直接在新建的不同页中添加自己需要的控件即可 123&lt;span style=&quot;font-family:Microsoft YaHei;&quot;&gt;点击TabPages属性可以添加选项并修改名称在不同TabPages中添加自己需要的控件即可&lt;strong&gt;注意：因为所有TabPages都是在同一个类中，故其中的控件ID不能重复&lt;/strong&gt;&lt;/span&gt; 版权声明：本文为博主原创文章，未经博主允许不得转载。]]></content>
      <tags>
        <tag>CSDN迁移</tag>
      </tags>
  </entry>
</search>
